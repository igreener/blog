<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://igreener.github.io</id>
    <title>unnull &apos;s blog</title>
    <updated>2020-03-11T11:08:38.585Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://igreener.github.io"/>
    <link rel="self" href="https://igreener.github.io/atom.xml"/>
    <subtitle>&lt;head&gt;
    &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/x-mathjax-config&quot;&gt;
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: [&apos;script&apos;, &apos;noscript&apos;, &apos;style&apos;, &apos;textarea&apos;, &apos;pre&apos;],
            inlineMath: [[&apos;$&apos;,&apos;$&apos;]]
delate:[[&apos;-&apos;,&apos;-&apos;]]
            }
   
        });
    &lt;/script&gt;
&lt;/head&gt;
</subtitle>
    <logo>https://igreener.github.io/images/avatar.png</logo>
    <icon>https://igreener.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, unnull &apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[快速幂1]]></title>
        <id>https://igreener.github.io/kuai-su-mi/</id>
        <link href="https://igreener.github.io/kuai-su-mi/">
        </link>
        <updated>2020-03-02T02:42:54.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>前置知识<br>
一个十进制数可以转化成一个二进制数 如9 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 1001</li>
</ul>
<hr>
<p>考虑一个问题</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;$&#039; in math mode at position 4: x^n$̲$其中   $0≤x,n&lt;2^…'>x^n$$其中   $0≤x,n&lt;2^{31}$  答案对1e9+7取模
---
---
显然 直接乘的复杂度为$\Theta  (n)$的 不够优
我们把n转化成二进制
如16 $\rightarrow$ 10000
可以发现$x^{16}$ = $x^8$* $x^8$ = $x^4$ * $x^4$ * $x^4$ * $x^4$=....
发现有大量的需要重复计算的地方
考虑优化
从末尾开始,对于n的二进制下的每一个1,将$x^{2^{len-1}}$乘入答案,后将该位置的1变为0(其中len为从右往左数第一个1的位置)
直到全为0为止
---
当然 在实现上是有点区别的
以下是代码
---
 ```
#define ll long long
const int mod =1e9+7;
ll qpow(int x,int n)
{
        ll ans =1;
        ll t =x;//累乘器
        while(n)
        {
            if(n&amp;1)//该位有1
            ans = ans * t % mod  ;
            t =t * t % mod ;
            n = n / 2 ;
        }
        return ans ;
}`
```
---
实际上，还有另一种做法:
由于题目有对答案取模
我们打表发现
当n足够大时
尾数会呈现周期性变化
将周期省略，减少计算次数,复杂度$\Theta  (不知道)$
并不推荐这种写法，这种写法需要一些空间
---
code:
```
#define ll long long 
const int maxn=1e5+7;//看情况进行选择
const int mod =1e9+7;
int a[maxn];
ll qpow(int x,int n)
{
    memset(a,0,sizeof(a));
    a[1]=x%mod;
    a[2]=x%mod*x%mod;
    if(a[1]==a[2])return a[1];
    int cnt=2;
    while(1)
    {
        cnt++;
        a[cnt]=a[cnt-1]*x%mod;
        if(a[cnt]==a[1]){cnt--;break;}
    }
    n=n%cnt;
    return a[n];
}
```

</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[test]]></title>
        <id>https://igreener.github.io/test/</id>
        <link href="https://igreener.github.io/test/">
        </link>
        <updated>2020-03-02T02:29:17.000Z</updated>
        <content type="html"><![CDATA[<p>233</p>
]]></content>
    </entry>
</feed>