<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://igreener.github.io</id>
    <title>hello!</title>
    <updated>2020-04-22T18:06:22.638Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://igreener.github.io"/>
    <link rel="self" href="https://igreener.github.io/atom.xml"/>
    <logo>https://igreener.github.io/images/avatar.png</logo>
    <icon>https://igreener.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, hello!</rights>
    <entry>
        <title type="html"><![CDATA[4.23 口讲]]></title>
        <id>https://igreener.github.io/TeyILKyiq/</id>
        <link href="https://igreener.github.io/TeyILKyiq/">
        </link>
        <updated>2020-04-22T03:02:56.000Z</updated>
        <content type="html"><![CDATA[<h2 id="link"><a href="https://wxn.qq.com/cmsid/AUS2020042000449902">link</a><br>
4月18日 一代精神领袖窃格瓦拉·周出狱。<br>
在出狱前 某乎上不乏出现这样的言论:<br>
<img src="https://igreener.github.io/post-images/1587540062238.png" alt="" loading="lazy"></h2>
<h2 id="但事实上这一波操作却是狠狠地打了某些人的脸-也正如他所说的打工是不可能打工的这辈子都不可能打工的-现在所说的之前说过了不打工-那你跟他签约你就是他的工人-要言而有信-让人感慨之余不禁敬佩这样言行合一的人怕是不多了-同时在视频中可以发现这位精神领袖的世界观没有被监狱中的环境所影响-甚至言行中还有着一丝朴素社会主义的味道-这对于一个没有学历的人来说或许在家务农也是他最好的选择吧">但事实上,<br>
这一波操作却是狠狠地打了某些人的脸。<br>
也正如他所说的:&quot;打工是不可能打工的，这辈子都不可能打工的。&quot;<br>
现在所说的:“之前说过了，不打工。那你跟他签约你就是他的工人。要言而有信。”<br>
让人感慨之余不禁敬佩，这样言行合一的人怕是不多了。<br>
同时在视频中可以发现，这位精神领袖的世界观没有被监狱中的环境所影响。甚至言行中还有着一丝朴素社会主义的味道。这对于一个没有学历的人来说<br>
或许，在家务农也是他最好的选择吧。</h2>
<h2 id="让我们把目光转向社会-社会影响力2年前大力哥出狱他选择了与切格瓦拉不同的道路选择了签约主播但反响平平-现在唯一能查到的消息就是ta浪子回头能自理更生最后消失在了我们的视野中-但切格瓦拉不同在监狱期间-网络上还流传着ta-的传说和表情包为什么社会上对于两者的关注度有这么大的影响下面都是我瞎bb的对于社会上的众多工薪阶层来说领袖说了他们不敢说的话他们没有他那样的魄力但又迫于生活的压力使得自己对ta有着一定的敬佩与一丝的崇拜至于大力哥-图个乐就好">让我们把目光转向社会。(社会影响力)<br>
2年前，&quot;大力哥&quot;出狱，他选择了与切格瓦拉不同的道路，选择了签约主播<br>
但反响平平 现在唯一能查到的消息就是ta浪子回头，能自理更生<br>
最后消失在了我们的视野中。<br>
但切格瓦拉不同<br>
在监狱期间 网络上还流传着ta 的&quot;传说&quot;和表情包<br>
为什么社会上对于两者的关注度有这么大的影响？(下面都是我瞎bb的)<br>
对于社会上的众多工薪阶层来说，&quot;领袖&quot;说了他们不敢说的话，他们没有他那样的魄力，<br>
但又迫于生活的压力，使得自己对ta有着一定的敬佩与一丝的崇拜<br>
至于大力哥 图个乐就好</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[区间dp]]></title>
        <id>https://igreener.github.io/qu-jian-dp/</id>
        <link href="https://igreener.github.io/qu-jian-dp/">
        </link>
        <updated>2020-03-11T09:02:17.000Z</updated>
        <content type="html"><![CDATA[<p>首先可以明确的一点是:对于一段区间,<strong>开始位置</strong>,<strong>最后位置</strong>.<strong>区间长度</strong>,这三个元素知二得一</p>
<hr>
<p>我们来看一道例题;</p>
<h2 id="usaco16open248-g"><a href="https://www.luogu.com.cn/problem/P3146">[USACO16OPEN]248 G</a></h2>
<p>题意<br>
给定一个1*n的地图，在里面玩2048，每次可以合并相邻两个（数值范围1-40），问最大能合出多少。注意合并后的数值并非加倍而是+1，例如2与2合并后的数值为3。<br>
输入<br>
共n+1行<br>
第一行为n<br>
剩下n行为地图中的元素<br>
输出<br>
合出的最大值<br>
样例:<br>
输入</p>
<pre><code>4
1
1
1
2
</code></pre>
<p>输出</p>
<pre><code>3
</code></pre>
<p>区间dp，实际上是将一种合区间的操作(自动联想并查集，并查集是合并集合)<br>
对于初始状态 每一个元素都是一个区间<br>
在特定条件下(数字相同时)合并来求得答案<br>
考虑如何表征一个区间<br>
不妨设f[i][j]为第i个位置到第j个位置的元素所构成区间<br>
由于一个区间是通过两个区间合并构成的<br>
所以f[i][j]是由两个区间合并构成的<br>
但两个区间的值不同 合并出来的值也会不同<br>
所以f[i][j]会有多值<br>
但f[i][j]作为下次合并的元素时,元素需要越大越好<br>
所以根据题意我们只需要求得f[i][j]的最大值<br>
我们直接设f[i][j]为i-&gt;j的最大值<br>
容易得到状态转移方程</p>
<pre><code>if(f[i][k]==f[k+1][j])
f[i][j]=max(f[i][j],f[i][k]+1)
</code></pre>
<p>其中i&lt;=k&lt;=j<br>
现在设计好了状态 方程也得出了 考虑实现<br>
一种比较智障的方式(我没学习前)是<br>
i,j,k分别循环然后一股脑塞入方程<br>
大概是这样</p>
<pre><code>for(int =i=1;i&lt;=n;++i)
{
    for(int j=1;j&lt;=i;++j)
    {
        for(int k=i;k&lt;=j;++k)
        {
         if(f[i][k]==f[k+1][j])
        f[i][j]=max(f[i][j],f[i][k]+1)
        ans =max(f[i][j],ans);
        }
    }
}
print(ans);
</code></pre>
<p>非常容易发现这样的实现方式是错误的<br>
我们不妨举个例子:<br>
我现在需要更新f[1][3]的区间最大值<br>
那么我需要的是f[1][1],f[1][2],f[2][3]<br>
但f[2][3]并没有值<br>
所以这样的做法是错误的<br>
让我们回头看看方程</p>
<pre><code>if(f[i][k]==f[k+1][j])
f[i][j]=max(f[i][j],f[i][k]+1)
</code></pre>
<p>上述已经说了<br>
是将小区间合并成大区间<br>
描绘区间的大小是用&quot;长度&quot;来刻画的<br>
不妨从长度开始枚举</p>
<pre><code>for(int i=1;i&lt;=n;++i)//初始化
f[i][i]=a[i];
for(int len=2;len&lt;=n;++i)//长度
{
    for(int l=1;l+len-1&lt;=n;++l)//左边
    {
        int r =l+len-1;
        for(int k=l;k&lt;r;++k)//中间节点 设f[l][k]为左区间 那么f[l+1][r]为右区间
        if(f[l][k]==f[k+1][r])
        {
            f[l][r]=max(f[l][r],f[l][k]);
            ans =max(ans,f[l][r])
        }
    }
}
</code></pre>
<p>总结:</p>
<ol>
<li>区间dp的思考方式</li>
<li>循环方式</li>
<li>注意边界的细节</li>
<li>状态的初始化</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[快速幂1]]></title>
        <id>https://igreener.github.io/kuai-su-mi/</id>
        <link href="https://igreener.github.io/kuai-su-mi/">
        </link>
        <updated>2020-03-02T02:42:54.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>前置知识<br>
一个十进制数可以转化成一个二进制数 如9 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 1001</li>
</ul>
<p>考虑一个问题<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">x^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>其中   <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>x</mi><mo separator="true">,</mo><mi>n</mi><mo>&lt;</mo><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">0≤x,n&lt;2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>  答案对1e9+7取模</p>
<p>显然 直接乘的复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta  (n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的 不够优<br>
我们把n转化成二进制<br>
如16 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 10000<br>
可以发现<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">x^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">x^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span>* <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">x^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">x^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span> * <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">x^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span> * <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">x^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span> * <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">x^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>=....<br>
发现有大量的需要重复计算的地方<br>
考虑优化<br>
从末尾开始,对于n的二进制下的每一个1,将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><msup><mn>2</mn><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></msup></mrow><annotation encoding="application/x-tex">x^{2^{len-1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.01192em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.01192em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9270285714285714em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>乘入答案,后将该位置的1变为0(其中len为从右往左数第一个1的位置)<br>
直到全为0为止</p>
<p>当然 在实现上是有点区别的</p>
<pre><code>#define ll long long
const int mod =1e9+7;
ll qpow(int x,int n)
{
       ll ans =1;
       ll t =x;//累乘器
       while(n)
       {
           if(n&amp;1)//该位有1
           ans = ans * t % mod  ;
           t =t * t % mod ;
           n = n / 2 ;
       }
       return ans ;
}
</code></pre>
<p>实际上，还有另一种做法:<br>
由于题目有对答案取模<br>
我们打表发现<br>
当n足够大时<br>
尾数会呈现周期性变化<br>
将周期省略，减少计算次数,复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><mi mathvariant="normal">不</mi><mi mathvariant="normal">知</mi><mi mathvariant="normal">道</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta  (不知道)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">知</span><span class="mord cjk_fallback">道</span><span class="mclose">)</span></span></span></span><br>
并不推荐这种写法，这种写法需要一些空间</p>
<pre><code>#define ll long long 
const int maxn=1e5+7;//看情况进行选择
const int mod =1e9+7;
int a[maxn];
ll qpow(int x,int n)
{
    memset(a,0,sizeof(a));
    a[1]=x%mod;
    a[2]=x%mod*x%mod;
    if(a[1]==a[2])return a[1];
    int cnt=2;
    while(1)
    {
        cnt++;
        a[cnt]=a[cnt-1]*x%mod;
        if(a[cnt]==a[1]){cnt--;break;}
    }
    n=n%cnt;
    return a[n];
}
</code></pre>
]]></content>
    </entry>
</feed>